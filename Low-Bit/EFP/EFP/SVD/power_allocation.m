function P_list=power_allocation(Sigma,P,noise,flg_b)
% Generate the water-filling power allocation matrix whose i th diagonal
% entry represent the power allocated to i th channel, given channel gains,
% total power, and noise power
%
% Based on:
%   https://zhuanlan.zhihu.com/p/502453127
%
% Inputs:
%   - Sigma: the channel gains matrix which usually generated by svd
%   - P: the total power
%   - noise: noise power
%   - flg_b: computation precision
%
% Outputs:
%   - P_list: the power allocation matrix
%
%
% log:
%   - initialized by Meidong Xia on 11/26/2023
%   - Using bisection algorithm by Meidong Xia on 01/21/2024
% 
%
% Rest of the code... 
size_0=size(Sigma,1);
lamda=zeros(1,size_0);
if flg_b == 1 % 64bit
    for i=1:size_0
        lamda(i)=noise/Sigma(i,i)^2;
    end
    w_pre = 0;
    w_next=200*P;
    while true
        w = (w_next+w_pre)/2;
        f = sum(max((w-lamda),0));
        if abs(f-P)<1e-5
            break
        end
        if f>P
            w_next = w; 
        else
            w_pre = w;       
        end
    end
    P_list=sqrt(diag(max((w-lamda),0)));
elseif flg_b==2 % 32bit
    for i=1:size_0
        lamda(i)=single(noise)/single(Sigma(i,i))^2;
    end
    w_pre = 0;
    w_next=single(200)*single(P);
    while true
        w = (single(w_next)+single(w_pre))/single(2);
        f = sum(max(single(w)-single(lamda),single(0)));
        if abs(single(f)-single(P))<1e-5
            break;
        end
        if f>P
            w_next = w; 
        else
            w_pre = w;       
        end
        
    end
    P_list=sqrt(diag(max(single(w)-single(lamda),single(0))));
elseif flg_b==3 % 16bit
    for i=1:size_0
        [~,~,sigma_tmp] = i_hp_mul(Sigma(i,i),Sigma(i,i));
        [~,~,lamda(i)]=i_hp_div(noise,sigma_tmp);
    end
    w_pre = 0;
    [~,~,w_next]=i_hp_mul(200,P);
    
    cnt = 1e2;
    while true
        [~,~,w_tmp] = i_hp_add(w_next,w_pre);
        [~,~,w] = i_hp_div(w_tmp,2);
        f = real(f_cal(w,lamda,0));
        [~,~,judge] = i_hp_sub(f,P);
        if real(abs(judge)) < 1e-5
            break;
        end
        if f>P
            w_next = w; 
        else
            w_pre = w;       
        end
        
        cnt = cnt-1;
        if cnt<0
            break
        end
    end
    P_list=diag(f_cal_tmp(w,lamda));
    for i=1:length(lamda)
        [~,P_list(i,i)] = i_hp_sqrt(P_list(i,i));
    end
end
end

function val = f_cal(w,lamda,P) % sum(max((w-lamda),0))-P
    tmp = f_cal_tmp(w,lamda);
    val = 0;
    for i=1:length(tmp)
        [~,~,val] = i_hp_add(val,tmp(i));
    end
    [~,~,val] = i_hp_sub(val,P);
end

function val = f_cal_tmp(w,lamda) % max((w-lamda),0)
    val = zeros(size(lamda));
    for i = 1:length(val)
        [~,~,tmp] = i_hp_sub(w,lamda(i));
        val(i) = max(real(tmp),0);
    end
end
