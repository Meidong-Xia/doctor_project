function Plist = f_power_optimization(P,Sigma,noise,rho,flg)
% Generate the power allocation matrix whose i th diagonal
% entry represent the power allocated to i th channel, given channel gains,
% total power, and noise power
%
% Based on:
%   
%
% Inputs:
%   - Sigma: the channel gains matrix which usually generated by svd
%   - P: the total power
%   - noise: noise power
%   - rho: the variance of computation error
%   - flg: 1: numerical method, 2: bisection method 
%
% Outputs:
%   - P_list: the power allocation matrix
%
%
% log:
%   - initialized by Meidong Xia on 01/21/2024
% 
%
% Rest of the code...
iter = 50; % 最大迭代次数
size_0=size(Sigma,1);
p = ones(size_0,1); % 功率向量随机化
y = zeros(size_0,1);
sigma = diag(Sigma); % 信道向量
f_pre = 0;

if flg == 1 % numerical + iteration
    for i = 1:iter
        p_total = sum(p);
        for j=1:size_0
            y(j)=(sqrt(sigma(j)^2*p(j)*(1+rho)))/(sigma(j)^2*rho*(p_total-p(j))+noise);
        end
        cvx_begin quiet
            variable p_v(size_0) nonnegative
            expression f
            expression tmp
            tmp = sum(p_v);
            for k=1:size_0
                f = f+log(1+2*y(k)*sqrt(p_v(k)*sigma(k)^2*(1+rho))+y(k)^2*((tmp-p_v(k))*sigma(k)^2*rho+noise));
            end
            maximize f
            subject to
                sum(p_v) == P;
        cvx_end
        p = p_v;
        if abs(f_pre-f) < 1e-5
            break
        end
        
        f_pre = f;
    end
    Plist = diag(sqrt(p));
elseif flg == 2 % close form + iteration
    for i=1:iter
        p_total = sum(p);
        for j=1:size_0
            y(j) = (sigma(j)^2*p(j)*(1+rho))/(sigma(j)^2*rho*(p_total-p(j))+noise);
        end
        a = (1+y).*sigma.^2*(1+rho);
        b = sigma.^2;
        c = P*sigma.^2*rho+noise;

        aa = a./b;
        cc = c./b;

        cvx_begin quiet
            variable pv(size_0) nonnegative
            expression f
            for j=1:size_0
                f = f+aa(j)-aa(j)*cc(j)*inv_pos(pv(j)+cc(j));
            end
            maximize f
            subject to
                sum(pv) == P;
        cvx_end

        p = pv;
        f = f+sum(log(1+y))-sum(y);

        
        % abs(f-f_pre)
        if abs(f-f_pre)<1e-5
            break
        end
        
        f_pre = f;
    end
    Plist = diag(sqrt(p));
elseif flg == 3 % bisection + iteration
    for i=1:iter
        p_total = sum(p);
        for j=1:size_0
            y(j) = (sigma(j)^2*p(j)*(1+rho))/(sigma(j)^2*rho*(p_total-p(j))+noise);
        end
        a = (1+y).*sigma.^2*(1+rho);
        b = sigma.^2;
        c = P*sigma.^2*rho+noise;

        

        mu_min = 0;
        mu_max = 100*P;
        val = 0;
        while abs(val-P) >= 1e-5
            mu = (mu_max+mu_min)/2;
            val = 0;
            for k = 1:size_0
                val = val+max((sqrt(a(k)*c(k)/mu)-c(k))/b(k),0);
            end
            if val>P
                mu_min = mu;
            elseif val<P
                mu_max = mu;
            end
        end

        for k = 1:size_0
            p(k)=max((sqrt(a(k)*c(k)/mu)-c(k))/b(k),0);
        end


        f = sum(log(1+y))-sum(y)+sum(((1+y).*p.*sigma.^2*(1+rho))./(sum(p)*sigma.^2*rho+p.*sigma.^2+noise));
        
        % abs(f-f_pre)
        if abs(f-f_pre)<1e-5
            break
        end
        
        f_pre = f;
    end
    Plist = diag(sqrt(p));
end
end