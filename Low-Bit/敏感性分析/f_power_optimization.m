function Plist = f_power_optimization(P,Sigma,noise,rho,flg)
% Generate the power allocation matrix whose i th diagonal
% entry represent the power allocated to i th channel, given channel gains,
% total power, and noise power
%
% Based on:
%   
%
% Inputs:
%   - Sigma: the channel gains matrix which usually generated by svd
%   - P: the total power
%   - noise: noise power
%   - rho: the variance of computation error
%   - flg: 1: numerical method, 2: bisection method 
%
% Outputs:
%   - P_list: the power allocation matrix
%
%
% log:
%   - initialized by Meidong Xia on 01/21/2024
% 
%
% Rest of the code...

size_0=size(Sigma,1);
sigma = diag(Sigma); % 信道向量
eposilon = 1e-5;

if flg == 1 % numerical
    
    cvx_begin quiet
        variable p(size_0) nonnegative
        expression f
        for i = 1:size_0
            f = f+P*rho*inv_pos(p(i))+noise*inv_pos(p(i)*sigma(i)^2);
        end
        minimize(f)
        subject to
            sum(p) == P;
    cvx_end
    Plist = diag(sqrt(p));

elseif flg == 2 % bisection 
    mu_min = 0;
    mu_max = 100*P;
    while mu_max - mu_min > 1e-5
        mu = (mu_max+mu_min)/2;
        val = 0;
        for i = 1:size_0
            tmp = sqrt(P*rho*sigma(i)^2+noise);
            val = val + max(tmp/(sigma(i)*sqrt(mu)),eposilon);
        end
        if abs(val-P)<1e-5
            break
        end
        if val>P
            mu_min = mu;
        elseif val<P
            mu_max = mu;
        end

    end
    p = zeros(size_0,1);
    for i = 1:size_0
        tmp = sqrt(P*rho*sigma(i)^2+noise);
        p(i) = max(tmp/(sigma(i)*sqrt(mu)),eposilon);
    end
    Plist = diag(sqrt(p));
end
end